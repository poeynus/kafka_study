# 카프카 공부 정리

## 카프카란?

***메시징 시스템***

비동기 통신 프로토콜을 지닌 즉각적인 응답이 필요 하지 않은 큐 시스템

메시지 큐는 서로 독립적으로 분리되어 처리

AMQP(Advanced Message Queuing Protocol) : 표준화된 메시징 프로토콜(TCP 5672), 신뢰성이 있는 메시지

> 카카오 구매하기, 구매내역은 RabbitMQ를 사용해서 서비스 하고 있음

***Pub Sub모델***

Publish, Subscribe, 메시지에 특정한 수신자가 정해져 있지 않다. 구독을 신청한 수신자에게 전달

> LinkedIn은 초창기에 ActiveMQ를 사용하여 구현했었는데 서비스가 커지고 불편하여서 kafka를 직접 개발 함

***카프카의 탄생***

기존에 느끼던 불편함을 해소하기 위해 개발, 복잡했던 구조가 카프카를 중간에 두니 간편해짐

> 1. 높은 처리량 
> 2. 실시간 로그 통합 
> 3. 무중단 
> 4. 이기종과의 호환성 
> 5. 스케일 아웃 
> 6. 프로듀서와 컨슈머 분리

***성능 비교***

ThroughPut : Kafka > Pulsar > RabbitMQ

End-To-End Latency Quantiles: Kafka > Pulsar > RabbitMQ

***컨플루언트**

카프카를 오픈소스로 등록 후, 타 회사에서 구성 요청이 왔는데 링크드인에서 발생했던 문제들이 똑같이 발생하는 것을 보고 수익성을 발견해 창립한 회사

***카프카***

오픈 소스 분산 이벤트 스트리밍 플랫폼이며, 쓰기에 최적화 된 플랫폼이다.

***사용 사례 및 사용 이유***

예상치 못한 대량의 요청이 올 경우 장애가 발생하게 된다. 카프카를 사용하면 비동기 이기에 이떄 보관하고 있다가 복구 될 시 안정적으로 처리할 수 있다.

> 1. 무향 로션 검색 
> 2. 무향 로션 검색 로그 카프카로 전달 (프로듀서)
> 3. 카프카에서 분석 시스템 내용 전달 (컨슈머)
> 4. 분석 결과 도출
> 5. 분석 결과 반영

> 적어도 한번 전송 방식: 중복은 괜찮은데 데이터가 유실 되면 안된다.

## 카프카 기본 구성

사진

프로듀서: 카프카로 데이터를 전송해주는 것

컨슈머: 카프카로 들어온 메시지를 꺼내서 사용하는 것 

> 예전에는 consumer offest을 주키퍼 저장소에 저장했었기 때문에 주키퍼와 컨슈머가 연결이 되어 있어야 했었다.

***카프카 클러스터**

주키퍼는 quorum mode로 인해 반드시 홀수로 구성해야 하고 브로커는 제한이 없다. 

주키퍼 3대, 브로커 3대가 기본이다.

## 주키퍼 

코디네이션 애플리케이션이다. 카프카의 메타 데이터를 관리한다. KIP-500이라고 주키퍼 제거를 논의 해서 제거 버전이 나오긴 했다.

분산 시스템과 병행하여 코디네이션 시스템 개발은 비효율적이다. 새로 만들기 보다는 주키퍼가 잘 되어 있어서 그대로 쓰기로 한 것이다.

카프카는 클러스터라 하지만 주키퍼는 앙상블이라 한다.

***주키퍼 구성***

분산 시스템의 저장소: 브로커, 토픽 정보 등

리더(write): 로컬에서 처리

팔로워(read): 리더가 처

***카프카 아키텍처***

> 카카오는 5대로 카프카 클러스터를 사용함
> 
> 주키퍼 하나에 카프카 여러 대를 붙여서 사용하기도 함

## 퀴즈

카프카 pub sub 모델은 초기 출시할 때 부터 목적은 decoupling이다.

토픽은 토픽 이름만으로 구분한다. 토픽은 확장할 수 있기에 멀티 컨슈머 멀티 프로듀서를 쓸 수 있다. 원하는대로 확장가능하다.

thickTime: 주기 
initLimit: 초기화 될때 까지의 시간 
syncLimit: 팔로우와 리더가 동기화 하는 시간





